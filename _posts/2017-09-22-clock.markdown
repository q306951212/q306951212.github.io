---
layout: post
title:  "浅谈mysql事务与锁机制!"
date:   2017-09-22 15:03:26 +0800
author:     "陈杨"
header-img: "img/post-bg-2015.jpg"
categories: jekyll update
catalog: true
tags:
    - 学习
---

> “Yeah It's on. ”


## 什么是事务

一个事务是一个连续一组的的数据库操作，就好像它是一个单一的工作单元，一个事物中的一系列操作要么全部成功，要么一个都不做。

## 事务的ACID

事务具有四个特性:原子性（ Atomicity ）、一致性（ Consistency ）、隔离性（ Isolation ）和持续性（ Durability ）。这四个特性简称为 ACID 特性.
### 原子性:

原子性是指事务所包含的操作要么全部成功，要么全部回滚,因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。
### 一致性:

一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。

例子1:　拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。

例子2:上述例子中A转账500给B,执行事务A-500,B+500，如果事务没有完成，只执行A-500，那么就不满足一致性!

总结:数据库中的数据是经常处于不一致的状态，这是不可避免的，因此我们提出了事务的概念，用于检测数据库中的数据是否处于一致性状态——如果数据库中有没有执行完的事务，那就是不一致的，否则，就是一致的。

### 隔离性:

一个事务的执行不能被其它事务干扰。即一个事务内部的操作及使用的数据对其它并发事务是隔离的，并发执行的各个事务之间不能互相干扰。

### 持久性:

也称永久性，指一个事务一旦提交，它对数据库中的数据的改变就应该是永久性的,在提交之前如果系统故障，则所有信息全部丢失。提交之后数据存放在磁盘中，是永久性的。

### 什么是脏数据

在数据库中脏数据在临时更新中产生。

事务A更新了某个数据项X，但是由于某种原因，事务A出现了问题，于是要把A回滚。但是在回滚之前，另一个事务B读取了数据项X的值(A更新后)，A回滚了事务，数据项恢复了原值。事务B读取的就是数据项X的就是一个“临时”的值，就是脏数据，依据脏数据所做的操作可能是不正确的！

## 什么是锁

锁是解决事务的隔离性的一种机制，事务的隔离级别通过锁来实现。总的来说MYSQL各存储引擎使用三种类型的锁机制：行级锁定，页级锁定，表级锁定。
* 行级锁:引擎(INNODB),单独一行记录加锁
* 页级锁:引擎(BDB)
* 表级锁:引擎(MyISAM),锁住整张表,可以同时读，不能写

### 行级锁

* 共享锁(读锁):用于锁定读取的数据资源,它是非独占的，允许其他事务同时读取锁定的资源。
* 排它锁(独占锁):适用于修改数据的场合,它锁定的资源其他事物不能读取。

当第一个事务访问某种数据库资源时，如果执行SELECT,必须先获得共享锁，如果执行INSERT,UPDATE,DELETE,必先获得排他锁。

当第二个事务也要访问相同的资源时，如果执行select语句，也必须先获得共享锁，如果执行insert、update或delete语句，也必须获得独占锁。此时根据已经旋转在资源上的锁的类型，来决定第二个事务应该等待第一个事务解除对应资源的锁定，还是可以立刻获得锁。

![Alt text](/img/ArticleImg3/img1.png)

###悲观锁和乐观锁

悲观锁(Pessimistic Lock),顾名思义,就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block(阻塞)直到它拿到锁。
传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。

乐观锁(Optimistic Lock), 顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁。
但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，表中有个版本号字段,通过版本号去查看是否更新，如果没有相同则跟新，否则不跟新。
乐观锁适用于多读的应用类型。






